∇⋅f = Tr(∇⊗f)
∇×f = Eᵢⱼₖ∇ⁱfʲ

∇ₓf = J⁻¹∇ₐf
∇ₓ⋅f = Tr(J⁻¹∇ₐ⊗f)
∇ₓ×f = Eᵢⱼₖ(J⁻¹∇ₐ)ⁱfʲ

∇ₓ⋅∇ₓf=Tr(J⁻¹∇ₐ⊗(J⁻¹∇ₐf))

∇ₓ⋅∇ₓf=(J⁻¹∇ₐ⊗(J⁻¹∇ₐf))ⁱⁱ





prototype?
	production?
		mitigations:
	x		ignoring irregular arrows
	x		regularizing irregular vertices
		methods:
			curvilinear method
			weighted linear
		polyhedron:
			pentakis dodecahedron
			fibonacci grid
		projections:
x	x		gnomonic (already effectively done, but required work to realize this)
x	x		healpix equal-area
			snyder equal-area
		other:
	x		move vector calculus to classes (necessary to attempt alternate methods)
	x		collignon with regularized vertices (easy, more out of curiosity)

